{ ---------------------------------------------------------------------	}
{ В данном файле находятся функции запуска синхронизации, а именно:		}
{ - цифровой синхронизации старта или покадровой                    		}
{ - аналоговой синхронизации по уровню или переходу							}
{ ---------------------------------------------------------------------	}

{ *********************************************************************	}
{ Установка типа синхронизации														}
{ *********************************************************************	}
Synchronization:
	AR = DM(SynchroType);			{ проверим тип синхронизации				}
	AR = PASS AR;
	IF EQ JUMP TtlSynchroStart;	{ если 0, то цифровая 						}
											{						синхронизация старта	}
	AR = AR - 0x1;
	IF EQ JUMP TtlSynchroKadr;		{ если 1, то покадровая        			}
											{ 					цифровая синхронизация	}
	AR = AR - 0x1;
	IF EQ JUMP AdcSynchroStart; 	{ если 2, то синхронизация 				}
											{								по каналу АЦП	}
	JUMP ErrorEndOfCommand;			{ выйдем с ошибкой в команде				}

{ *********************************************************************	}
{ цифровая синхронизация старта														}
{ *********************************************************************	}
TtlSynchroStart:
{ проинициализируем необходимые указатели и переменные						}
/*	CALL InitAdcPointers;*/

{ очистим запросы на прерывания, кроме IRQ2 (команды),						}
{								 SPORT1 Transmit (ЦАП) и SPORT1 Receive (ЦАП)	}
	IFC = 0x79;

{ запишем в AVR режим цифровой синхронизация	старта (7 бит)					}
	AR = 0x10B; CALL SendUartData;
	AR = 0x80; CALL SendUartData;

{ небольшая задержка																		}
	CNTR = 100; CALL Delay;			{ задержка 100 клоков DSP - 3.4 мкс		}

{ размаскируем прерывание IRQ2(команда)											}
	AR = DM(IMASK_VALUE);
	AR = SETBIT 5 OF AR;				{ размаскируем SPORT0 Receive (АЦП)		}
	DM(IMASK_VALUE) = AR;
{ теперь можно установить маску прерываний										}
	IMASK = AR;

{ теперь запустим AVR, вызвав прерывание INT1 для микроконтроллера		}
	CALL AVR_INT1;

{ установим флажок разрешиния работы АЦП											}
	AR = 0x1; DM(AdcEnable) = AR;

{ завершим команду																		}
	JUMP EndOfCommand;

{ *********************************************************************	}
{ покадровая цифровая синхронизация													}
{ *********************************************************************	}
TtlSynchroKadr:
{ проинициализируем необходимые указатели и переменные						}
/*	CALL InitAdcPointers;*/

{ очистим запросы на прерывания, кроме IRQ2 (команды),						}
{								 SPORT1 Transmit (ЦАП) и SPORT1 Receive (ЦАП)	}
	IFC = 0x79;

{ запишем в AVR режим покадровой цифровой синхронизации (6 бит)			}
	AR = 0x10B; CALL SendUartData;
	AR = 0x40; CALL SendUartData;

{ небольшая задержка																		}
	CNTR = 100; CALL Delay;			{ задержка 100 клоков DSP - 3.4 мкс		}

{ размаскируем прерывание IRQ2(команда)											}
	AR = DM(IMASK_VALUE);
	AR = SETBIT 5 OF AR;				{ размаскируем SPORT0 Receive (АЦП)		}
	DM(IMASK_VALUE) = AR;
{ теперь можно установить маску прерываний										}
	IMASK = AR;

{ теперь запустим AVR, вызвав прерывание INT1 для микроконтроллера		}
	CALL AVR_INT1;

{ установим флажок разрешения работы АЦП											}
	AR = 0x1; DM(AdcEnable) = AR;

{ завершим команду																		}
	JUMP EndOfCommand;

{ *********************************************************************	}
{ синхронизация по каналу АЦП															}
{ *********************************************************************	}
AdcSynchroStart:
{ установим новый обработчик прерываний SPORT0 Receive 						}
{										специально для аналоговой синхронизации	}
	AR = ^AdcSynchroIntrHandler; I7 = AR;

{ а по месту метки MainLoop надо прописать код CALL AdcSynchroIdle		}
	AR = ^MainLoop; I5 = AR;
	AR = ^AdcSynchroIdle;
	CALL ModifyCall;

{ пропишем в AVR номер синхроканала													}
	AR = 0x105; CALL SendUartData;
	AR = DM(SynchroAdChannel); CALL SendUartData;

{ запишем в AVR режим аналоговой синхронизации (5 бит)						}
	AR = 0x10B; CALL SendUartData;
	AR = 0x20; CALL SendUartData;

{ очистим запросы на прерывания, кроме IRQ2 (команды),						}
{								 SPORT1 Transmit (ЦАП) и SPORT1 Receive (ЦАП)	}
	IFC = 0x79;

{ размаскируем прерывание IRQ2(команда)											}
	AR = DM(IMASK_VALUE);
	AR = SETBIT 5 OF AR;				{ размаскируем SPORT0 Receive (АЦП)		}
	DM(IMASK_VALUE) = AR;
{ теперь можно установить маску прерываний										}
	IMASK = AR;

{ первый шаг аналоговой синхронизации												}
	AR = 0x0; DM(SynchroAdStep) = AR;

{ сбросим флажок, что было прерывание от АЦП										}
	MR0 = 0x0;

{ теперь запустим AVR, вызвав прерывание INT1 для микроконтроллера		}
	CALL AVR_INT1;

{ завершим команду																		}
	JUMP EndOfCommand;

{ *********************************************************************	}
{ анализируем отсчёты с синхроканала												}
{ *********************************************************************	}
AdcSynchroIdle:
{ проверим было ли прерывание от АЦП												}
	NONE = PASS MR0; IF EQ RTS;
{ сбросим флажок прерывания от АЦП													}
	MR0 = 0x0;
{ сохраним код с синхроканала в регистре AR										}
	AR = MR1;

{ в регистре AR получили код с канала синхронизации 							}
	AY0 = DM(SynchroAdSensitivity); 		{ по уровню или переходу			}
	NONE = PASS AY0;
	IF NE JUMP StepSynchro;

LastAdSynchro:
	AY0 = DM(SynchroAdPorog);		 		{ порог аналоговой синхронизации	}
	AR = AR - AY0;
	AY0 = DM(SynchroAdMode);
	NONE = PASS AY0;
	IF EQ AR = -AR;
	NONE = PASS AR;
	IF LT JUMP SynchroAdDetected;
	RTS;

StepSynchro:
	AY0 = DM(SynchroAdStep);
	NONE = PASS AY0;
	IF NE JUMP LastAdSynchro;
	AY0 = DM(SynchroAdPorog);
	AR = AR - AY0;
	AY0 = DM(SynchroAdMode);
	NONE = PASS AY0;
	IF NE AR = -AR;
	NONE = PASS AR;
	IF GE RTS;
	AR = 0x1; DM(SynchroAdStep) = AR;
	RTS;

SynchroAdDetected:
{ теперь запустим AVR, вызвав прерывание INT1 для микроконтроллера		}
	CALL AVR_INT1;

{ очистим запросы на прерывания, кроме IRQ2 (команды),						}
{								 SPORT1 Transmit (ЦАП) и SPORT1 Receive (ЦАП)	}
	IFC = 0x79;

{ восстановим стандартный обработчик прерываний IRQL0 						}
	AR = ^GetAdData; I7 = AR;

{ наконец по месту метки MainLoop надо прописать код CALL PutAcdData		}
	AR = ^MainLoop; I5 = AR;
	AR = ^PutAcdData;
	CALL ModifyCall;

	RTS;

{ *********************************************************************	}
{ Обработчик прерываний SPORT0 Receive при аналоговой 						}
{														синхронизации по каналу АЦП	}
{ *********************************************************************	}
AdcSynchroIntrHandler:
{ считаем значение АЦП с синхроканала												}
	MR1 = RX0;
{ установим флажок, что было прерывание от АЦП									}
	MR0 = 0x1;

	RTI;

{ *********************************************************************	}
{ Записать в PM по заданному адресу команду JUMP xxx			    			}
{ Вход:                                                     	  			}
{      I5 - адрес, куда записывается команда             					}
{      AR - адрес перехода xxx														}
{ *********************************************************************	}
ModifyJump:
{ запрещаем все прерывания																}
/*	DIS INTS;*/

{ Формируем код команды 																}
	SR1=0x0018;								{ 00000000 00011000 										}
	SR0=0x000F;								{ 00000000 00001111 						}
	SR=SR OR LSHIFT AR BY 4(LO);
	PX=SR0;									{ Получили 8 младших бит 				}
	AR=SR1;
	SR=LSHIFT SR0 BY -8(LO);
	SR=SR OR LSHIFT AR BY -8(HI);		{ Получили старшие 16 бит 				}
	M5=1;
	PM(I5,M5)=SR0;							{ Сохранили все 24-битовое слово 	}

{ разрешаем все прерывания																}
/*	ENA INTS;*/

	RTS;

{ *********************************************************************	}
{ Записать в PM по заданному адресу команду CALL xxx			    			}
{ Вход:                                                     	  			}
{      I5 - адрес, куда записывается команда             					}
{      AR - адрес перехода xxx														}
{ *********************************************************************	}
ModifyCall:
{ запрещаем все прерывания																}
/*	DIS INTS;*/

{ Формируем код команды 																}
	SR1=0x001C;								{ 00000000 00011100 						}
	SR0=0x000F;								{ 00000000 00001111 						}
	SR=SR OR LSHIFT AR BY 4(LO);
	PX=SR0;									{ Получили 8 младших бит 				}
	AR=SR1;
	SR=LSHIFT SR0 BY -8(LO);
	SR=SR OR LSHIFT AR BY -8(HI);		{ Получили старшие 16 бит 				}
	PM(I5,M5)=SR0;							{ Сохранили все 24-битовое слово 	}

{ разрешаем все прерывания																}
/*	ENA INTS;*/

	RTS;
