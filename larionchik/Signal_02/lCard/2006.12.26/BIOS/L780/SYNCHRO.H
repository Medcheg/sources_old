{ ---------------------------------------------------------------------	}
{ В данном файле находятся функции запуска синхронизации, а именно:		}
{ - цифровой синхронизации старта или покадровой                    		}
{ - аналоговой синхронизации по уровню или переходу							}
{ ---------------------------------------------------------------------	}

{ *********************************************************************	}
{ Установка типа синхронизации														}
{ *********************************************************************	}
Synchronization:
{ очистим запросы на прерывания, кроме IRQ2 (команды),						}
{								 SPORT1 Transmit (ЦАП) и SPORT1 Receive (ЦАП)	}
	IFC = 0x79;

	AR = DM(SynchroType);			{ проверим тип синхронизации				}
	AR = PASS AR;
	IF EQ JUMP TtlSynchroStart;	{ если 0, то цифровая 						}
											{						синхронизация старта	}
	AR = AR - 0x1;
	IF EQ JUMP TtlSynchroKadr;		{ если 1, то покадровая        			}
											{ 					цифровая синхронизация	}
	AR = AR - 0x1;
	IF EQ JUMP AdcSynchroStart;	{ если 2, то синхронизация 				}
											{								по каналу АЦП	}
	JUMP ErrorEndOfCommand;			{ выйдем с ошибкой в команде				}

{ *********************************************************************	}
{ цифровая синхронизация старта														}
{ *********************************************************************	}
TtlSynchroStart:
{ проинициализируем необходимые указатели и переменные						}
/*	CALL InitAdcPointers;*/

{ флажок = 0x0 --> цифровая синхронизацмя старта								}
/*	AR = 0x0; DM(IsTtlKadrSynchro) = AR;*/

{ установим флажок, что разрешена работа АЦП										}
	AR = 0x1; DM(AdcEnable) = AR;

{ для режима синхронизации старта в AX1 должен находиться					}
{	 													код включения клоков SPORT0	}
	AX1 = 0x7C1F;

{ очистим запросы на прерывания, кроме IRQ2 (команды),						}
{								 SPORT1 Transmit (ЦАП) и SPORT1 Receive (ЦАП)	}
	IFC = 0x79;

{ разрешим прерывания IRQ2 (команда) и, возможно, SPORT1 Transmit (ЦАП)	}
{								 							 или SPORT1 Receive (ЦАП)	}
	AR = DM(IMASK_VALUE);
	AR = SETBIT 4 OF AR;				{ размаскируем IRQE (внеш. синхр.)		}
	DM(IMASK_VALUE) = AR;
{ теперь можно установить маску прерываний										}
	IMASK = AR;

{ завершим команду																		}
	JUMP EndOfCommand;

{ *********************************************************************	}
{ покадровая цифровая синхронизация													}
{ *********************************************************************	}
TtlSynchroKadr:
{ проинициализируем необходимые указатели и переменные						}
/*	CALL InitAdcPointers;*/

{ флажок != 0x0 --> покадровая цифровая синхронизацмя							}
/*	AR = 0x1; DM(IsTtlKadrSynchro) = AR;*/
{ установим флажок, что разрешена работа АЦП										}
	AR = 0x1; DM(AdcEnable) = AR;

{ управляющая таблица состоит только из одного канала?						}
	AR = DM(ControlTableLenght); AR = AR - 0x1;
	IF EQ JUMP SetOneSampleIrql0Handler;

{ а по месту метки Irql0Lab0 надо прописать код JUMP TtlSynchroIrql0		}
	AR = ^Irql0Lab0; I5 = AR;
	AR = ^TtlSynchroIrql0;
	CALL ModifyJump;

	JUMP SetTtlSynchroKadrPars;

SetOneSampleIrql0Handler:
{ будем использовать специальный обработчик прерывания IRQL0 				}
{					  при одном отсчёте в кадре при покадровой синхронизации	}
	AR = ^TtlSynchroLastKadrSample; I7 = AR;

SetTtlSynchroKadrPars:
{ для режима покадровой синхронизации в AX1 должен находиться				}
{	 													код включения клоков SPORT0	}
	AX1 = 0x7C1F;
	ENA SEC_REG;						{ перейдем на второй банк регистров		}
		AR = AX0 - 0x1; AX0 = AR;	{ AX0 = (кол-во каналов - 1) 				}
		AF = PASS AX0;					{ AF - текущий счетчик прерываний		}
	DIS SEC_REG;					  	{ перейдем на первый банк регистров		}

{ очистим запросы на прерывания, кроме IRQ2 (команды),						}
{								 SPORT1 Transmit (ЦАП) и SPORT1 Receive (ЦАП)	}
	IFC = 0x79;

{ разрешим прерывания IRQ2 (команда) и, возможно, SPORT1 Transmit (ЦАП)	}
{								 							 или SPORT1 Receive (ЦАП)	}
	AR = DM(IMASK_VALUE);
	AR = SETBIT 4 OF AR;				{ размаскируем IRQE (внеш. синхр.)		}
	DM(IMASK_VALUE) = AR;
{ теперь можно установить маску прерываний										}
	IMASK = AR;

{ завершим команду																		}
	JUMP EndOfCommand;

{ *********************************************************************	}
{ синхронизация по каналу АЦП															}
{ *********************************************************************	}
AdcSynchroStart:
{ проинициализируем необходимые указатели и переменные						}
/*	CALL InitAdcPointers;*/

{ запишем логический номер синхроканала аналоговой синхронизации			}
{														в сквозной и пром. регистр		}
	AR = DM(SynchroAdChannel);
{ FL0 в единицу - доступ к сквозному регистру									}
	SET FL0;
{ запись в сквозной регистр логического номера первого канала АЦП			}
	IO(SET_ADC_CHANNEL) = AR;
{ FL0 в ноль - доступ к промежуточному регистру									}
	RESET FL0;
{ запись в промежуточный регистр логического номера второго канала АЦП	}
	IO(SET_ADC_CHANNEL) = AR;

{ межканальная задержка, чтобы установился аналоговый тракт					}
	CALL SettlingDelay;

{ установим новый обработчик прерываний IRQL0 									}
{										специально для аналоговой синхронизации	}
	AR = ^IrqL0AdcSample; I7 = AR;

{ а по месту метки MainLoop надо прописать код CALL AdSynchroIdle			}
	AR = ^MainLoop; I5 = AR;
	AR = ^AdcSynchroIdle;
	CALL ModifyCall;

{ очистим запросы на прерывания, кроме IRQ2 (команды),						}
{								 SPORT1 Transmit (ЦАП) и SPORT1 Receive (ЦАП)	}
	IFC = 0x79;

{ разрешим прерывания IRQ2, IRQL0 и, возможно, SPORT1 Transmit				}
{								 							 или SPORT1 Receive (ЦАП)	}
	AR = DM(IMASK_VALUE);
	AR = SETBIT 7 OF AR;				{ размаскируем IRQL0 (АЦП)					}
	DM(IMASK_VALUE) = AR;
{ теперь можно установить маску прерываний										}
	IMASK = AR;

{ первый шаг аналоговой синхронизации												}
	AR = 0x0; DM(SynchroAdStep) = AR;
{ сбросим флажок, что было прерывание от АЦП										}
	MR0=0x0;

{ разрешим АЦП включив клоки, т.е. сделаем SCLK внутренним					}
	AR = 0x7C1F;						{ 0111 1100 1100 1111						}
	DM(Sport0_Ctrl_Reg) = AR;		{ 0x3FF6 - SPORT0 Control Register		}

{ завершим команду																		}
	JUMP EndOfCommand;

{ *********************************************************************	}
{ анализируем отсчёты с синхроканала												}
{ *********************************************************************	}
AdcSynchroIdle:
{ проверим было ли прерывание от АЦП												}
	NONE = PASS MR0; IF EQ RTS;
{ сбросим флажок прерывания от АЦП													}
	MR0 = 0x0;
{ сохраним код с синхроканала в регистре AR										}
	AR = MR1;

{ в регистре AR получили код с канала синхронизации 							}
	AY0 = DM(SynchroAdSensitivity); 		{ по уровню или переходу			}
	NONE = PASS AY0;
	IF NE JUMP StepSynchro;

LastAdSynchro:
	AY0 = DM(SynchroAdPorog);		 		{ порог аналоговой синхронизации	}
	AR = AR - AY0;
	AY0 = DM(SynchroAdMode);
	NONE = PASS AY0;
	IF EQ AR = -AR;
	NONE = PASS AR;
	IF LT JUMP SynchroAdDetected;
	RTS;

StepSynchro:
	AY0 = DM(SynchroAdStep);
	NONE = PASS AY0;
	IF NE JUMP LastAdSynchro;
	AY0 = DM(SynchroAdPorog);
	AR = AR - AY0;
	AY0 = DM(SynchroAdMode);
	NONE = PASS AY0;
	IF NE AR = -AR;
	NONE = PASS AR;
	IF GE RTS;
	AR = 0x1; DM(SynchroAdStep) = AR;
	RTS;

SynchroAdDetected:
{ Остановим АЦП, выключив клоки SCLK , т.е. сделаем их внешним				}
	AR = 0x3C1F; 						{ 0011 1100 0001 1111 						}
	DM(Sport0_Ctrl_Reg) = AR;		{ 0x3FF6 - SPORT0 Control Register		}

{ размаскируем прерывание IRQ2(команда) и, возможно, SPORT1 Transmit		}
{								 							 или SPORT1 Receive (ЦАП)	}
	AR = DM(IMASK_VALUE);
	AR = CLRBIT 4 OF AR;				{ замаскируем IRQE (внеш. синхр.)		}
	AR = CLRBIT 7 OF AR;				{ замаскируем IRQL0 (АЦП)					}
	DM(IMASK_VALUE) = AR;
{ теперь можно установить маску прерываний										}
	IMASK = AR; NOP;

{ задержка на 2.0 мкс, чтобы оцифрился последний отсчет						}
	CALL Delay2mks;
{ заново установим указатель на управляющую таблицу							}
	I2 = ^ControlTable;
{ запишем логические номера первых каналов в сквозной и пром. регистр	}
	CALL SetAdcFirstChannel;
	AX0 = DM(I2, M2);					{ следующий номер канала					}

{ восстановим стандартный обработчик прерываний IRQL0 						}
	AR = ^GetAdData; I7 = AR;

{ наконец по месту метки MainLoop надо прописать код CALL PutAcdData		}
	AR = ^MainLoop; I5 = AR;
	AR = ^PutAcdData;
	CALL ModifyCall;

{ теперь можно сбросить запрос на прерывание IRQL0								}
	AR = IO(READ_ADC);

{ установим флажок, что разрешена работа АЦП										}
	AR = 0x1; DM(AdcEnable) = AR;

{ очистим запросы на прерывания, кроме IRQ2 (команды),						}
{								 SPORT1 Transmit (ЦАП) и SPORT1 Receive (ЦАП)	}
	IFC = 0x79;

{ размаскируем прерывание IRQ2(команда) и, возможно, SPORT1 Transmit		}
{								 							 или SPORT1 Receive (ЦАП)	}
	AR = DM(IMASK_VALUE);
	AR = SETBIT 7 OF AR;				{ размаскируем IRQL0 (АЦП)					}
	DM(IMASK_VALUE) = AR;
{ теперь можно установить маску прерываний										}
	IMASK = AR; NOP;

{ разрешим АЦП включив клоки, т.е.сделаем SCLK внутренним					}
	AR = 0x7C1F;						{ 0111 1100 1100 1111						}
	DM(Sport0_Ctrl_Reg) = AR;		{ 0x3FF6 - SPORT0 Control Register		}

	RTS;

{ *********************************************************************	}
{ Обработчик прерываний IRQL0 ввода одиночных отсчетов, используемый		}
{ при аналоговой синхронизации по каналу АЦП и в функции AdChannel		}
{ *********************************************************************	}
IrqL0AdcSample:
{ считаем значение АЦП с синхроканала												}
	MR1=IO(READ_ADC);

{ установим флажок, что было прерывание от АЦП									}
	MR0=0x1;

	RTI;

{ *********************************************************************	}
{ Записать в PM по заданному адресу команду JUMP xxx			    			}
{ Вход:                                                     	  			}
{      I5 - адрес, куда записывается команда             					}
{      AR - адрес перехода xxx														}
{ *********************************************************************	}
ModifyJump:
{ запрещаем все прерывания																}
/*	DIS INTS;*/

{ Формируем код команды 																}
	SR1=0x0018;								{ 00000000 00011000 										}
	SR0=0x000F;								{ 00000000 00001111 						}
	SR=SR OR LSHIFT AR BY 4(LO);
	PX=SR0;									{ Получили 8 младших бит 				}
	AR=SR1;
	SR=LSHIFT SR0 BY -8(LO);
	SR=SR OR LSHIFT AR BY -8(HI);		{ Получили старшие 16 бит 				}
	PM(I5,M5)=SR0;							{ Сохранили все 24-битовое слово 	}

{ разрешаем все прерывания																}
/*	ENA INTS;*/

	RTS;

{ *********************************************************************	}
{ Записать в PM по заданному адресу команду CALL xxx			    			}
{ Вход:                                                     	  			}
{      I5 - адрес, куда записывается команда             					}
{      AR - адрес перехода xxx														}
{ *********************************************************************	}
ModifyCall:
{ запрещаем все прерывания																}
/*	DIS INTS;*/

{ Формируем код команды 																}
	SR1=0x001C;								{ 00000000 00011100 						}
	SR0=0x000F;								{ 00000000 00001111 						}
	SR=SR OR LSHIFT AR BY 4(LO);
	PX=SR0;									{ Получили 8 младших бит 				}
	AR=SR1;
	SR=LSHIFT SR0 BY -8(LO);
	SR=SR OR LSHIFT AR BY -8(HI);		{ Получили старшие 16 бит 				}
	PM(I5,M5)=SR0;							{ Сохранили все 24-битовое слово 	}

{ разрешаем все прерывания																}
/*	ENA INTS;*/

	RTS;
