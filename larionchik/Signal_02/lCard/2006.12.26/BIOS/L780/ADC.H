{ ---------------------------------------------------------------------	}
{	Функции для работы с АЦП															}
{ ---------------------------------------------------------------------	}
{ *********************************************************************	}
{ получение данных с АЦП - прерывание IRQL0 (Read ADC data)					}
{ *********************************************************************	}
GetAdData:
{ установим очередной канал															}
	IO(SET_ADC_CHANNEL) = AX0;
{ подготовим следующий канал															}
	AX0 = DM(I2, M2);

{ перейдем на второй банк регистров													}
	ENA SEC_REG;

{ чтение данных с АЦП																	}
	AR = IO(READ_ADC);

{ корректировка смещения																}
	AR = AR + AY1, AY1 = DM(I1,M1);
{ корректировка масштаба																}
	MR = AR * MY1(SU), MY1 = DM(I1,M1);
{ округление																				}
	MR = MR(RND);
{ кладём в буфер АЦП																		}
	DM(I3, M3) = MR1;

{	для обычного сбора (без покадровой синхронизации):							}
{		- если нет межкадровой задержки 	- RTI										}
{ 		- если есть межкадровая задержка - AF=AF-0x1 							}
{ для покадровой синхронизации   - JUMP TtlSynchroIrql0						}
Irql0Lab0:
	AF = AF - 0x1;
{ это последний отсчёт в кадре?														}
	IF EQ JUMP Irql0Lab1;

{ это предпоследний отсчёт в кадре?													}
	NONE = AF - 0x1;
	IF NE RTI;

{ указатель I2 на начало управляющей таблицы 									}
	M2 = 0x0;
	I2 = ^ControlTable;
	DIS SEC_REG;					  	{ перейдем на первый банк регистров		}
	AX0 = DM(I2, M2);

	RTI;

Irql0Lab1:
{ указатель I7 на обработчик для межкадровой задержки							}
	AR = ^InterKadrDelayIrql0; I7 = AR;
{ для межкадровой задержки в AF кол-во клоков межкадровой задержки,		}
	AF = PASS AX1;
{ проверим сколько тактов межкадровой задержки нам нужно						}
	NONE = AF - 0x1;
{ если нужен только один тактов межкадровой задержки - JUMP IkdIrql0Lab1}
	IF EQ JUMP IkdIrql0Lab1;

	RTI;

{ *********************************************************************	}
{ обработчик прерываний IRQL0 для межкадровой задержки						}
{ *********************************************************************	}
InterKadrDelayIrql0:
{ установим следующий канал															}
	IO(SET_ADC_CHANNEL) = AX0;
{ подготовим следующий канал															}
	AX0 = DM(I2, M2);

{ перейдем на второй банк регистров													}
	ENA SEC_REG;
{ чтение данных с АЦП - сброс прерывния IRQL0									}
	AR = IO(READ_ADC);

{ посчитаем кол-во клоков нужных для межкадровой задержки					}
	AF = AF - 0x1;
	IF EQ JUMP IkdIrql0Lab0;

{ это предпоследний отсчёт межкадровой задержки?								}
	NONE = AF - 0x1;
	IF NE RTI;

IkdIrql0Lab1:
	M2 = 0x1; MODIFY(I2, M2);
	DIS SEC_REG;					  	{ перейдем на первый банк регистров		}
	AX0 = DM(I2, M2);

	RTI;

IkdIrql0Lab0:
{ восстановим стандартный обработчик прерываний IRQL0							}
	AR = ^GetAdData; I7 = AR;
{ теперь в AF - кол-во каналов в кадре												}
	AF= PASS AX0;

	RTI;

{ *********************************************************************	}
{ 	изменение обработчика IRQL0 для последнего отсчёта в кадре				}
{ *********************************************************************	}
TtlSynchroIrql0:
{ это последний отсчёт в кадре?														}
	AF = AF - 0x1; IF NE RTI;

{ будем использовать специальный обработчик прерывания IRQL0 для 			}
{				  последнего отсчёта в кадре при покадровой синхронизации	}
	AR = ^TtlSynchroLastKadrSample; I7 = AR;

{ перейдем на первый банк регистров													}
	DIS SEC_REG;
{ положим в AX1 код выключения клоков SPORT0										}
	AX1 = 0x3C1F;						{ 0011 1100 0001 1111						}

	RTI;

{ *********************************************************************	}
{ Специальный обработчик прерывания IRQL0	для последнего отсчёта 			}
{ 									  в кадре при при покадровой синхронизации	}
{ 	Разрешим IRQE для внешнего импульса по-кадровой синхронизации			}
{ *********************************************************************	}
TtlSynchroLastKadrSample:
{ Остановим АЦП, выключив клоки SCLK , т.е. сделаем их внешним				}
	DM(Sport0_Ctrl_Reg) = AX1;		{ 0x3FF6 - SPORT0 Control Register		}

{ установим очередной канал															}
	IO(SET_ADC_CHANNEL) = AX0;
{ подготовим следующий канал															}
	AX0 = DM(I2, M2);

{ перейдем на второй банк регистров													}
	ENA SEC_REG;
{ чтение данных с АЦП																	}
	AR = IO(READ_ADC);
{ корректировка смещения																}
	AR = AR + AY1, AY1 = DM(I1,M1);
{ корректировка масштаба																}
	MR = AR * MY1(SU), MY1 = DM(I1,M1);
{ округление																				}
	MR = MR(RND);
{ кладём скорректированный отсчёт в буфер АЦП									}
	DM(I3, M3) = MR1;

{ восстановим стандартный обработчик прерываний IRQL0							}
	AR = ^GetAdData;
{ или будем использовать специальный обработчик прерывания IRQL0 			}
{					  при одном отсчёте в кадре при покадровой синхронизации	}
	AY0 = ^TtlSynchroLastKadrSample;
{ для покадровой в регистре AF должен находиться (размер кадра-1)			}
	AF = PASS AX0; IF EQ AR = PASS AY0;
{ будем использовать адрес полученного обработчика								 }
	I7 = AR;

{ разрешим прерывания IRQ2(команда) и IRQE(внешняя синхронизация)			}
	AR = DM(IMASK_VALUE);
	AR = SETBIT 4 OF AR;				{ размаскируем IRQE (внеш. синхр.)		}
	AR = CLRBIT 7 OF AR;				{ замаскируем IRQL0 (АЦП)					}
	DM(IMASK_VALUE) = AR;

	DIS INTS;							{ запретим все прерывания					}
{ положим в стэк регистр IMASK с новым значением								}
	POP STS; IMASK = DM(IMASK_VALUE); PUSH STS;
	IMASK = 0x0;

{ установим признак вхождения в прерывание										}
	AF = PASS 0x1;

{ очистим запросы на прерывания, кроме IRQ2 (команды),						}
{								 SPORT1 Transmit (ЦАП) и SPORT1 Receive (ЦАП)	}
	IFC = 0x79;

{ теперь в AX1 должен быть код включения клоков SPORT0						}
	AX1 = 0x7C1F;						{ 0111 1100 0001 1111						}

	ENA INTS;							{ разрешим все прерывания					}

	RTI;

{ *********************************************************************	}
{ КОМАНДЫ РАБОТЫ С АЦП																	}
{ *********************************************************************	}
{ Команда установки временных параметров кадра:   								}
{ 			частоты сбора данных с АЦП и межкадровой задержки каналов АЦП	}
Set_Adc_Kadr_cmd:
{ Команда загрузки управляющей таблицы												}
Load_Control_Table_cmd:
{  Команда конфигурирования FIFO буфера АЦП 										}
{  устанавливаются значения адреса FIFO, его длина и место размещения  	}
ADC_Fifo_Config_cmd:
{ Команда разрешение/запрещение работы АЦП, а также							}
{ 				команда разрешение/запрещение генерирования прерываний в PC	}
Restart_ADC:
Enable_ADC_cmd:
Enable_IRQ_PC_cmd:
{ Команда синхронизации																	}
Synchro_Config_cmd:
{ выключим клоки, т.е.сделаем SCLK внешним 										}
	AR = 0x3C1F; 						{ 0011 1100 0001 1111 						}
	DM(Sport0_Ctrl_Reg) = AR;		{ 0x3FF6 - SPORT0 Control Register		}

EnableAdcCmdMasking:
{ сбросим признак вхождения в прерывание											}
	AF = PASS 0x0;
{ размаскируем прерывание IRQ2(команда)											}
	AR = DM(IMASK_VALUE);
	AR = CLRBIT 4 OF AR;				{ замаскируем IRQE (внеш. синхр.)		}
	AR = CLRBIT 7 OF AR;				{ замаскируем IRQL0 (АЦП)					}
	DM(IMASK_VALUE) = AR;
{ проверим заходили ли мы в какое-нибудь прерывание?							}
	NONE = PASS AF; IF NE JUMP EnableAdcCmdMasking;
{ теперь можно установить маску прерываний										}
	IMASK = AR;

{ задержка на 2.7 мкс, чтобы оцифрился последний отсчет						}
	CALL Delay2p7mks;
{ после этого можно сделать сброс прерывания IRQL0								}
	AR = IO(READ_ADC);

{ очистим запросы на прерывания, кроме IRQ2 (команды),						}
{								 SPORT1 Transmit (ЦАП) и SPORT1 Receive (ЦАП)	}
	IFC = 0x79;

{ по месту метки MainLoop пропишем код CALL PutAcdData						}
	AR = ^MainLoop; I5 = AR;
	AR = ^PutAcdData;
	CALL ModifyCall;

{ проинициализируем необходимые указатели и переменные						}
	CALL InitAdcPointers;
{ запишем логические номера первых каналов в сквозной и пром. регистр	}
/*	CALL SetAdcFirstChannel;*/
{ межканальная задержка, чтобы установился аналоговый тракт					}
/*	CALL SettlingDelay;*/

{ установим частоту запуска АЦП														}
	AR = DM(AdcRate);
	DM(Sport0_Sclkdiv) = AR;		{ 0x3FF5 - Serial Clock Divide Modulus	}

{ для начала проверим тип синхронизации											}
	AR = DM(SynchroType); AR = ABS AR;
{ если есть синхронизация, то переменная SynchroType 							}
{														должна быть равна 0, 1 или 2	}
	AR = AR - 0x2;
	IF LE JUMP Synchronization;

{ посмотрим разрешена ли работа АЦП													}
	AR = DM(AdcEnable); AR = PASS AR;
	IF EQ JUMP EndOfCommand;

{ очистим запросы на прерывания, кроме IRQ2 (команды),						}
{								 SPORT1 Transmit (ЦАП) и SPORT1 Receive (ЦАП)	}
	IFC = 0x79;

{ разрешим прерывания IRQ2 (команда) и, возможно, SPORT1 Transmit (ЦАП)	}
{								 							 или SPORT1 Receive (ЦАП)	}
	AR = DM(IMASK_VALUE);
	AR = SETBIT 7 OF AR;				{ размаскируем IRQL0 (АЦП)					}
	DM(IMASK_VALUE) = AR;
{ теперь можно установить маску прерываний										}
	IMASK = AR; NOP;

{ включим клоки, т.е. сделаем SCLK внутренним									}
	AR = 0x7C1F;						{ 0111 1101 1100 1111						}
	DM(Sport0_Ctrl_Reg) = AR;		{ 0x3FF6 - SPORT0 Control Register		}

{ завершим команду																		}
	JUMP EndOfCommand;

{ *********************************************************************	}
{	Установка указателей	для работы АЦП												}
{ *********************************************************************	}
InitAdcPointers:
{ проверим тип DSP																		}
	Call CheckDspType;
{ установим требуемые размеры FIFO буфера АЦП									}
	CALL CheckAdcFifoLimits;

{ установим параметры для корректировки входных данных						}
	I0 = ^ControlTable; M0 = 0x1; L0 = 0x0;

	I1 = ^CalibrationArray; M1 = 0x1;
	AR = DM(ControlTableLenght);		 	{ длина управляющей таблицы		}
	SR = LSHIFT AR BY 1 (LO);				{ умножим на два						}
	L1 = SR0;

{ разрешена ли корректировка входных данных										}
	AR = DM(IsCorrectionEnable); NONE = PASS AR;
	IF EQ JUMP NoAdcDataCorrection;{ если да, готовим соответствующий массив}

{ параметры работы указателя I2														}
	M2 = 0x0; L2 = 0x0;

	CNTR = DM(ControlTableLenght); 		{ длина управляющей таблицы		}
	DO CtrlLoop UNTIL CE;
		AR = DM(I0, M0);
		SR = LSHIFT AR BY -6 (LO);
		M2 = SR0;

{	 	Set ZeroOffset																		}
		I2 = ^ZeroOffsetArray;
		MODIFY(I2,M2);
		AR = DM(I2,M2);
		DM(I1,M1) = AR;

{	 	Set ScaleFactor																	}
		I2 = ^ScaleFactorArray;
		MODIFY(I2,M2);
		AR = DM(I2,M2);
		DM(I1,M1) = AR;
CtrlLoop: NOP;

ContinueAdcPar:

{ Set ADC Fifo Parameters (указатель на 'голову' FIFO АЦП)					}
	I3 = DM(AdcFifoBaseAddress);
	M3 = 0x1;
	L3 = DM(AdcFifoLength);
	DM(AdcFifoPointer) = I3;
	DM(IrqDataAddress) = I3;

{ указатель на 'хвост' FIFO буфера АЦП												}
	I0 = I3;
{ в M0 должен быть шаг прерываний буфера АЦП										}
	M0 = DM(AdcIrqStep);
	L0 = L3;

{ Set pointer to ControlTable															}
	I2 = ^ControlTable;
	M2 = 0x1;
	L2 = DM(ControlTableLenght);

{ массив коэффициентов для корректировки смещения нуля и масштаба АЦП	}
	I1 = ^CalibrationArray;
	M1 = 0x1;
	AR = DM(ControlTableLenght); 			{ длина управляющей таблицы		}
	SR = LSHIFT AR BY 1 (LO);				{ умножим на два						}
	L1 = SR0;

{ управление генерированием прерываний в РС от имени АЦП						}
	AR = DM(EnableIrqValue); DM(EnableAdcIrq) = AR;

{ запишем логические номера первых каналов в сквозной и пром. регистр	}
	CALL SetAdcFirstChannel;

{ сохраним в регистрах нужные в работе АЦП параметры							}
	AX0 = DM(I2, M2);					{ следующий номер канала					}
	ENA SEC_REG;						{ перейдем на второй банк регистров		}
		AY1=DM(I1,M1);                   { коэф. корректировки смещения	}
		MY1=DM(I1,M1);                   { коэф. корректировки  масштаба	}
		AX0 = DM(ControlTableLenght);		{ AX0 - кол-во активных каналов 	}
		AF = PASS AX0;							{ AF - текущий счетчик прерываний}
		AX1 = DM(InterKadrDelay);			{ AX1 - межкадровая задержка		}
	DIS SEC_REG;					  	{ перейдем на первый банк регистров		}

{ и сбросим флажок работы в режиме по-кадровой синронизации					}
/*	AR = 0x0; DM(IsTtlKadrSynchro) = AR;*/

{ по месту метки Irql0Lab0 пропишем код RTI										}
	AR = ^Irql0Lab0; I5 = AR;
	AR = 0x0A00; PX = 0x1F;
	PM(I5, M5) = AR;

{ восстановим стандартный обработчик прерываний IRQL0							}
	AR = ^GetAdData; I7 = AR;

{ проверим есть ли межкадровая задержка											}
	AR = DM(InterKadrDelay); NONE= PASS AR; IF EQ RTS;

{ при наличии межкадровой задержки													}
{	 				по месту метки Irql0Lab0 надо прописать код AF=AF-0x1		}
	AR = ^Irql0Lab0; I5 = AR;
	AR = 0x2710; PX = 0x0F;
	PM(I5, M5) = AR;

	RTS;

{ *********************************************************************	}
{ Если корректировка не нужна, готовим соответствующий массив				}
{ *********************************************************************	}
NoAdcDataCorrection:
{ длина управляющей таблицы															}
	CNTR = DM(ControlTableLenght);
	DO CtrlLoop1 UNTIL CE;
{	 	Set ZeroOffset																		}
		AR = 0x0; DM(I1,M1) = AR;

{	 	Set ScaleFactor																	}
		AR = 0x7FFF; DM(I1,M1) = AR;

CtrlLoop1: 	NOP;

	JUMP ContinueAdcPar;

