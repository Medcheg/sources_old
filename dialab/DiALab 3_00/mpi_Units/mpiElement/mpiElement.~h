//---------------------------------------------------------------------------
#ifndef mpiElementH
#define mpiElementH
//---------------------------------------------------------------------------
#include "mpiBaseClass.h"
//#include "mpiVisualElementParam.h"
#include "mpiPoints.h"
//---------------------------------------------------------------------------
enum TOrientation  {oRight, oBottom, oLeft, oTop};
enum TRecurseState {rsBeginState, rsWait, rsDone};
enum TDesignPhase  {dpNotTesting, dpNeedModified, dpAllreadyTesting};
//---------------------------------------------------------------------------
//###########################################################################
typedef struct {
   int           CountIn;          // ---------- Временная переменная нужная для при составлениии правильной последовательности просчета элемента (уточняю нужная для рекурсии) ----
   int           CountOut;         // ---------- Временная переменная нужная для при составлениии правильной последовательности просчета элемента (уточняю нужная для рекурсии) ----
   TRecurseState State;            // ---------- На какой стадии рекурсии находится элемент ------
   bool          inCalculateList;  // ---------- Находиться ли елемент в списке счета схемы ??? -------------
}TRecurse;
//###########################################################################
class TVisualElementParam ;
class TElement : public TBaseClass{
private:
      TOrientation           fOrientation;
      TVisualElementParam   *fVisualElementParam;
    // -----
       int                  fOrder;           // ----------- Порядок передаточной фукции элемента ------
    // -----
       TPoints   *fInPoints ;   // --- Входы элемента  (In Points)-----
       TPoints   *fOutPoints;   // --- Выходы элемента (Out Points) -----

    // -----
       //Graphics::TBitmap *fResourseBitmapFaceElement; // --- Лицо елемента (если не рисуем сами то загружаем из ресурса)-------
    // -----

       bool          fShowInOutHint;
       bool          fNeedRedraw; // ----Нужно ли перерисовывать элемент -------
       bool          fShadow;     // ---- Тень елемента ----

       TDesignPhase  fDesignPhase;    // ---- тестирован ли елемент, нетестирован, или находится в процессе разработки ----
/*       void __fastcall Set_Shadow(bool aValue) { if (fShadow == aValue) return; fShadow = aValue; DrawElementFace(); }
    // -----
               void  Draw_Shadow (TCanvas *aCanvas);
               void  Draw_Caption(TCanvas *aCanvas);
               void  Draw_In     (TCanvas *aCanvas);
               void  Draw_Out    (TCanvas *aCanvas);
               void  Draw_InHint (TCanvas *aCanvas);
               void  Draw_OutHint(TCanvas *aCanvas);
               //void __fastcall Set_Orientation(TOrientation aOrientation);

*/
       void __fastcall Set_Order(int aValue);
public:
      // ---------
        TRecurse   Recurse;  // ---- Структура - с помощью которой раставляем порядок счета элементов --------
      // ---------

       TElement();
       virtual ~TElement();

       virtual void        DrawElementFace() = 0;      // ---- Отрисовка лица елемента ---
       virtual void        Init();                     // ---- Инициялизация єлемента перед просчетом ----
       virtual void        InitBeforeRun()   = 0;      // ---- Как правило , єто задание начальніх условий елемента ----
       virtual void        Run();                      // ---- Счет елемента ----------
       virtual bool        isEnabledCalc();            // ---- Проверка можно ли считать елемент (задел для разнотактовой системы) ----------
       virtual void        DoneRun() = 0;              // ---- Кому нада тому еще и кончаем счет елемента ----------
       virtual void        Copy(void *aElement);            // --- Копирование елемента ------
       virtual void        SaveToStream  (FILE *aStream);   // --- Запись елемента -------
       virtual void        LoadFromStream(FILE *aStream);   // --- чтение елемента из фалового потока -------
       virtual bool        IsElementInSelectedRegion(int aParentId, int ax1, int ay1, int ax2, int ay2);  // ---- находиться ли елемент в Выделяемом регионе МЫШИ ---
               void        RotateElemenet();

/*       virtual void        Draw(TCanvas *aCanvas, int aParentId);
       virtual void        Draw_SelectedElement(TCanvas *aCanvas);
       virtual TBaseClass *WhereMouse(int aParentId, TMouseParam &mp, int xPos, int yPos);
       virtual void        MoveElement(TCanvas *aCanvas, int aOffsetX, int aOffsetY);
       virtual void        EndMoveElement();



     __property bool                   Shadow                    = { read = fShadow                   , write = Set_Shadow          };
     __property TOrientation           Orientation               = { read = fOrientation                                            };
     __property Graphics::TBitmap     *ResourseBitmapFaceElement = { read = fResourseBitmapFaceElement, write = fResourseBitmapFaceElement};
*/
     __property TPoints               *iPoints                   = { read = fInPoints                 , write = fInPoints           };    // --- Входы элемента  (In Points)-----
     __property TPoints               *oPoints                   = { read = fOutPoints                , write = fOutPoints          };    // --- Выходы элемента (Out Points) -----
     __property int                    Order                     = { read = fOrder                    , write = Set_Order           };   // ---- Порядок очереди елемента (количество точек запоминания) ----
     __property TVisualElementParam   *VisualElementParam        = { read = fVisualElementParam       , write = fVisualElementParam };
     __property TDesignPhase           DesignPhase               = { read = fDesignPhase              , write = fDesignPhase        };
     __property bool                   NeedRedraw                = { read = fNeedRedraw               , write = fNeedRedraw         };
     __property bool                   ShowInOutHint             = { read = fShowInOutHint            , write = fShowInOutHint      };
};
#endif
